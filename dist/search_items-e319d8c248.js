searchNodes=[{"doc":"Bitcoin P2PK, P2PKH, P2SH, P2WPKH, P2WSH script/address generate and validate demo.SupportedP2PKHP2SHP2WPKHP2WSHUsageentropy = Btc.Util.strong_rand() {:ok, {priv_key, address}} = Btc.Address.generate(:p2pkh, :mainnet, entropy) true = Btc.Address.verify?(:p2pkh, :mainnet, address){:ok, {priv_key, address}} = Btc.Address.generate(:p2sh, :mainnet) true = Btc.Address.verify?(:p2sh, :mainnet, address){:ok, {priv_key, address}} = Btc.Address.generate(:p2wpkh, :testnet) true = Btc.Address.verify?(:p2wpkh, :testnet, address)","ref":"Btc.html","title":"Btc","type":"module"},{"doc":"","ref":"Btc.html#version/0","title":"Btc.version/0","type":"function"},{"doc":"Bitcoin P2PK, P2PKH, P2SH, P2WPKH, P2WSH script/address generate and validate demo.SupportedP2PKHP2SHP2WPKHP2WSHUsageentropy = Btc.Util.strong_rand() {:ok, {priv_key, address}} = Btc.Address.generate(:p2pkh, :mainnet, entropy) true = Btc.Address.verify?(:p2pkh, :mainnet, address){:ok, {priv_key, address}} = Btc.Address.generate(:p2sh, :mainnet) true = Btc.Address.verify?(:p2sh, :mainnet, address){:ok, {priv_key, address}} = Btc.Address.generate(:p2wpkh, :testnet) true = Btc.Address.verify?(:p2wpkh, :testnet, address)","ref":"Btc.Address.html","title":"Btc.Address","type":"behaviour"},{"doc":"Given a address and a network type, check if the address is valid","ref":"Btc.Address.html#c:address_valid?/2","title":"Btc.Address.address_valid?/2","type":"callback"},{"doc":"https://github.com/mbrix/libsecp256k1/blob/master/test/libsecp256k1_tests.erl","ref":"Btc.Address.html#create_public_key/2","title":"Btc.Address.create_public_key/2","type":"function"},{"doc":"","ref":"Btc.Address.html#generate/3","title":"Btc.Address.generate/3","type":"function"},{"doc":"Given a 32 bytes random binary and a network type, return a valid bitcoin address.","ref":"Btc.Address.html#c:generate_address/2","title":"Btc.Address.generate_address/2","type":"callback"},{"doc":"","ref":"Btc.Address.html#generate_private_key/1","title":"Btc.Address.generate_private_key/1","type":"function"},{"doc":"Return type of current module","ref":"Btc.Address.html#c:type/0","title":"Btc.Address.type/0","type":"callback"},{"doc":"","ref":"Btc.Address.html#valid?/3","title":"Btc.Address.valid?/3","type":"function"},{"doc":"","ref":"Btc.Address.html#t:address/0","title":"Btc.Address.address/0","type":"type"},{"doc":"","ref":"Btc.Address.html#t:compression/0","title":"Btc.Address.compression/0","type":"type"},{"doc":"","ref":"Btc.Address.html#t:entropy/0","title":"Btc.Address.entropy/0","type":"type"},{"doc":"","ref":"Btc.Address.html#t:generate_result/0","title":"Btc.Address.generate_result/0","type":"type"},{"doc":"https://en.bitcoin.it/wiki/Testnet","ref":"Btc.Address.html#t:network/0","title":"Btc.Address.network/0","type":"type"},{"doc":"","ref":"Btc.Address.html#t:private_key/0","title":"Btc.Address.private_key/0","type":"type"},{"doc":"","ref":"Btc.Address.html#t:public_key/0","title":"Btc.Address.public_key/0","type":"type"},{"doc":"","ref":"Btc.Address.html#t:type/0","title":"Btc.Address.type/0","type":"type"},{"doc":"Pay-to-Public-Key-HashLinkshttps://en.bitcoinwiki.org/wiki/Pay-to-Pubkey_Hashhttps://en.bitcoin.it/wiki/List_of_address_prefixeshttps://bitcoin.stackexchange.com/questions/72775/is-it-possible-to-convert-an-address-from-p2pkh-to-p2shScriptPubKey and ScriptSig DisplayScriptPubKey= OP_DUP OP_HASH160 &lt;Public KeyHash&gt; OP_EQUAL OP_CHECKSIG ScriptSig= &lt;Signature&gt; &lt;Public Key&gt;StructA = BASE58CHECK( 0x00 HASH160( K ) ) Where HASH160( K ) is equivalent to RIPEMD160( SHA256( K ) ) and 0x00 represents the version byte (for P2PKH)Summarymainnetprefix: 0leading symbol: 1example: 17VZNX1SN5NtKa8UQFxwQbFeFc3iqRYhemtestnetprefix: 111leading symbol: m or nexample: mipcBbFg9gMiCh81Kj8tqqdgoZub1ZJRfnDoctest mainnetiex&gt; network = :mainnet ...&gt; entropy = Btc.Util.strong_rand() ...&gt; {:ok, {_priv_key, address}} = Elixir.Btc.Addresses.P2pkh.generate_address(entropy, network) ...&gt; Elixir.Btc.Addresses.P2pkh.address_valid?(address, network) trueDoctest testnetiex&gt; network = :testnet ...&gt; entropy = Btc.Util.strong_rand() ...&gt; {:ok, {_priv_key, address}} = Elixir.Btc.Addresses.P2pkh.generate_address(entropy, network) ...&gt; Elixir.Btc.Addresses.P2pkh.address_valid?(address, network) true","ref":"Btc.Addresses.P2pkh.html","title":"Btc.Addresses.P2pkh","type":"module"},{"doc":"Exampleiex&gt; Elixir.Btc.Addresses.P2pkh.address_valid?(&quot;17VZNX1SN5NtKa8UQFxwQbFeFc3iqRYhem&quot;, :mainnet) true iex&gt; Elixir.Btc.Addresses.P2pkh.address_valid?(&quot;mipcBbFg9gMiCh81Kj8tqqdgoZub1ZJRfn&quot;, :testnet) true iex&gt; Elixir.Btc.Addresses.P2pkh.address_valid?(&quot;foo&quot;, :mainnet) false","ref":"Btc.Addresses.P2pkh.html#address_valid?/2","title":"Btc.Addresses.P2pkh.address_valid?/2","type":"function"},{"doc":"Exampleiex&gt; Elixir.Btc.Addresses.P2pkh.generate_address(&lt;&lt;0::big-256&gt;&gt;, :mainnet) {:error, &#39;Public key generation error&#39;} iex&gt; entropy = &lt;&lt;72, 160, 32, 203, 107, 197, 248, 91, 227, 205, 37, 63, 217, 112, 82, 227, 131, 44, 56, 160, 180, 66, 7, 116, 181, 203, 125, 58, 172, 54, 181, 102&gt;&gt; iex&gt; {:ok, {priv_key, mainnet_address}} = Elixir.Btc.Addresses.P2pkh.generate_address(entropy, :mainnet) iex&gt; {:ok, {^priv_key, testnet_address}} = Elixir.Btc.Addresses.P2pkh.generate_address(entropy, :testnet) ...&gt; {mainnet_address, testnet_address, byte_size(priv_key)} {&quot;1EmCKjrbhRJ7znmCg1LRTjZ5nHHxSVhUqJ&quot;, &quot;muH9cnwaWSjNmuEpPaJoHemQeGtfPJRV5R&quot;, 32}","ref":"Btc.Addresses.P2pkh.html#generate_address/2","title":"Btc.Addresses.P2pkh.generate_address/2","type":"function"},{"doc":"Pay-to-Script-HashLinkshttps://en.bitcoin.it/wiki/Pay_to_script_hashhttps://en.bitcoin.it/wiki/BIP_0016https://en.bitcoin.it/wiki/List_of_address_prefixeshttps://en.bitcoin.it/wiki/Script#OpcodesScriptPubKey and ScriptSig DisplayscriptSig: [signature] {[pubkey] OP_CHECKSIG} scriptPubKey: OP_HASH160 [20-byte-hash of {[pubkey] OP_CHECKSIG} ] OP_EQUALStructA 1 of 1 multisig transaction is created by concatenating the following byte values: OP_0 0x14 HASH160( K ) A = BASE58CHECK( 0x05 HASH160( OP_0 0x14 HASH160( K ) ) ) Where 0x05 is the version byte for script hash addresses and 0x14 is the amount of bytes to expect in the HASH160( K ).Summarymainnetprefix: 5leading symbol: 3example: 3EktnHQD7RiAE6uzMj2ZifT9YgRrkSgzQXtestnetprefix: 196leading symbol: 2example: 2MzQwSSnBHWHqSAqtTVQ6v47XtaisrJa1VcDoctest mainnetiex&gt; network = :mainnet ...&gt; entropy = Btc.Util.strong_rand() ...&gt; {:ok, {_priv_key, address}} = Elixir.Btc.Addresses.P2sh.generate_address(entropy, network) ...&gt; Elixir.Btc.Addresses.P2sh.address_valid?(address, network) trueDoctest testnetiex&gt; network = :testnet ...&gt; entropy = Btc.Util.strong_rand() ...&gt; {:ok, {_priv_key, address}} = Elixir.Btc.Addresses.P2sh.generate_address(entropy, network) ...&gt; Elixir.Btc.Addresses.P2sh.address_valid?(address, network) true","ref":"Btc.Addresses.P2sh.html","title":"Btc.Addresses.P2sh","type":"module"},{"doc":"Exampleiex&gt; Elixir.Btc.Addresses.P2sh.address_valid?(&quot;3EktnHQD7RiAE6uzMj2ZifT9YgRrkSgzQX&quot;, :mainnet) true iex&gt; Elixir.Btc.Addresses.P2sh.address_valid?(&quot;2MzQwSSnBHWHqSAqtTVQ6v47XtaisrJa1Vc&quot;, :testnet) true iex&gt; Elixir.Btc.Addresses.P2sh.address_valid?(&quot;foo&quot;, :mainnet) false","ref":"Btc.Addresses.P2sh.html#address_valid?/2","title":"Btc.Addresses.P2sh.address_valid?/2","type":"function"},{"doc":"Pay-to-Witness-Public-Key-HashLinkshttps://en.bitcoin.it/wiki/BIP_0173https://en.bitcoin.it/wiki/BIP_0141#P2WPKHhttps://en.bitcoin.it/wiki/BIP_0142https://en.bitcoin.it/wiki/BIP_0144https://en.bitcoin.it/wiki/List_of_address_prefixeshttps://programmingblockchain.gitbook.io/programmingblockchain/other_types_of_ownership/p2wpkh_pay_to_witness_public_key_hashSummaryFor P2WPKH address, the address version is 6 (0x06) for a main-network address or 3 (0x03) for a testnet address.0 &lt;20-byte-key-hash&gt;mainnetprefix: bcexample: bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4testnettestnet: tbexample: tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsxDoctest mainnetiex&gt; network = :mainnet ...&gt; entropy = Btc.Util.strong_rand() ...&gt; {:ok, {_priv_key, address}} = Elixir.Btc.Addresses.P2wpkh.generate_address(entropy, network) ...&gt; Elixir.Btc.Addresses.P2wpkh.address_valid?(address, network) trueDoctest testnetiex&gt; network = :testnet ...&gt; entropy = Btc.Util.strong_rand() ...&gt; {:ok, {_priv_key, address}} = Elixir.Btc.Addresses.P2wpkh.generate_address(entropy, network) ...&gt; Elixir.Btc.Addresses.P2wpkh.address_valid?(address, network) true","ref":"Btc.Addresses.P2wpkh.html","title":"Btc.Addresses.P2wpkh","type":"module"},{"doc":"Exampleiex&gt; Elixir.Btc.Addresses.P2wpkh.address_valid?(&quot;bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4&quot;, :mainnet) true iex&gt; Elixir.Btc.Addresses.P2wpkh.address_valid?(&quot;tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx&quot;, :testnet) true iex&gt; Elixir.Btc.Addresses.P2wpkh.address_valid?(&quot;foo&quot;, :mainnet) false","ref":"Btc.Addresses.P2wpkh.html#address_valid?/2","title":"Btc.Addresses.P2wpkh.address_valid?/2","type":"function"},{"doc":"Pay-To-Witness-Script-HashLinkshttps://en.bitcoin.it/wiki/BIP_0173https://en.bitcoin.it/wiki/BIP_0141#P2WSHhttps://en.bitcoin.it/wiki/BIP_0142https://en.bitcoin.it/wiki/List_of_address_prefixeshttps://programmingblockchain.gitbook.io/programmingblockchain/other_types_of_ownership/p2wsh_pay_to_witness_script_hashSummaryFor P2WSH address, the address version is 10 (0x0A) for a main-network address or 40 (0x28) for a testnet address.0 &lt;32-byte-hash&gt;mainnetprefix: bcexample: bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3testnettestnet: tbexample: tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7Doctest mainnetiex&gt; network = :mainnet ...&gt; entropy = Btc.Util.strong_rand() ...&gt; {:ok, {_priv_key, address}} = Elixir.Btc.Addresses.P2wsh.generate_address(entropy, network) ...&gt; Elixir.Btc.Addresses.P2wsh.address_valid?(address, network) trueDoctest testnetiex&gt; network = :testnet ...&gt; entropy = Btc.Util.strong_rand() ...&gt; {:ok, {_priv_key, address}} = Elixir.Btc.Addresses.P2wsh.generate_address(entropy, network) ...&gt; Elixir.Btc.Addresses.P2wsh.address_valid?(address, network) true","ref":"Btc.Addresses.P2wsh.html","title":"Btc.Addresses.P2wsh","type":"module"},{"doc":"Exampleiex&gt; Elixir.Btc.Addresses.P2wsh.address_valid?(&quot;bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3&quot;, :mainnet) true iex&gt; Elixir.Btc.Addresses.P2wsh.address_valid?(&quot;tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7&quot;, :testnet) true iex&gt; Elixir.Btc.Addresses.P2wsh.address_valid?(&quot;foo&quot;, :mainnet) false","ref":"Btc.Addresses.P2wsh.html#address_valid?/2","title":"Btc.Addresses.P2wsh.address_valid?/2","type":"function"},{"doc":"https://en.bitcoin.it/wiki/Base58Check_encoding http://lenschulwitz.com/base58Creating a Base58Check stringTake the version byte and payload bytes, and concatenate them together (bytewise).Take the first four bytes of SHA256(SHA256(results of step 1))Concatenate the results of step 1 and the results of step 2 together (bytewise).Treating the results of step 3 - a series of bytes - as a single big-endian bignumber, convert to base-58 using normal mathematical steps (bignumber division) and the base-58 alphabet described below. The result should be normalized to not have any leading base-58 zeroes (character '1').The leading character '1', which has a value of zero in base58, is reserved for representing an entire leading zero byte, as when it is in a leading position, has no value as a base-58 symbol. There can be one or more leading '1's when necessary to represent one or more leading zero bytes. Count the number of leading zero bytes that were the result of step 3 (for old Bitcoin addresses, there will always be at least one for the version/application byte; for new addresses, there will never be any). Each leading zero byte shall be represented by its own character '1' in the final result.Concatenate the 1's from step 5 with the results of step 4. This is the Base58Check result.","ref":"Btc.Base58Check.html","title":"Btc.Base58Check","type":"module"},{"doc":"Exampleiex&gt; Elixir.Btc.Base58Check.decode(&quot;17VZNX1SN5NtKa8UQFxwQbFeFc3iqRYhem&quot;) {:ok, {&lt;&lt;0&gt;&gt;, &lt;&lt;71, 55, 108, 111, 83, 125, 98, 23, 122, 44, 65, 196, 202, 155, 69, 130, 154, 185, 144, 131&gt;&gt;}}","ref":"Btc.Base58Check.html#decode/1","title":"Btc.Base58Check.decode/1","type":"function"},{"doc":"","ref":"Btc.Base58Check.html#encode/2","title":"Btc.Base58Check.encode/2","type":"function"},{"doc":"SummaryBech32 is a segwit address format specified by BIP 0173. This address format is also known as &quot;bc1 addresses&quot;. Bech32 is more efficient with block space. As of October 2020, the Bech32 address format is supported in many popular wallets and is the preferred address schemeA Bech32[2] string is at most 90 characters long and consists of:The human-readable part, which is intended to convey the type of data, or anything else that is relevant to the reader. This part MUST contain 1 to 83 US-ASCII characters, with each character having a value in the range [33-126]. HRP validity may be further restricted by specific applications.The separator, which is always &quot;1&quot;. In case &quot;1&quot; is allowed inside the human-readable part, the last one in the string is the separator[3].The data part, which is at least 6 characters long and only consists of alphanumeric characters excluding &quot;1&quot;, &quot;b&quot;, &quot;i&quot;, and &quot;o&quot;[4].ExampleExamples of the address format being used on mainnet are the TXIDs 4ef47f6eb681d5d9fa2f7e16336cd629303c635e8da51e425b76088be9c8744c 514a33f1d46179b89e1fea7bbb07b682ab14083a276979f91038369d1a8d689b And addresses bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq bc1qc7slrfxkknqcq2jevvvkdgvrt8080852dfjewde450xdlk4ugp7szw5tk9","ref":"Btc.Bip0173.html","title":"Btc.Bip0173","type":"module"},{"doc":"Software interpreting a segwit address:MUST verify that the human-readable part is &quot;bc&quot; for mainnet and &quot;tb&quot; for testnet.MUST verify that the first decoded data value (the witness version) is between 0 and 16, inclusive.https://github.com/f2pool/bech32-elixir/blob/master/lib/bech32.ex#L257 https://en.bitcoin.it/wiki/Bech32 https://en.bitcoin.it/wiki/BIP_0173Exampleiex&gt; match?({:ok, :mainnet, 3, _}, Elixir.Btc.Bip0173.decode(&quot;bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4&quot;)) true","ref":"Btc.Bip0173.html#decode/1","title":"Btc.Bip0173.decode/1","type":"function"},{"doc":"See Bech32.encode/2.","ref":"Btc.Bip0173.html#encode/2","title":"Btc.Bip0173.encode/2","type":"function"},{"doc":"Basic bitcoin library Bitcoin P2PK, P2PKH, P2SH, P2WPKH, P2WSH script/address generate and validate demo.SupportedP2PKHP2SHP2WPKHP2WSH","ref":"readme.html","title":"Basic bitcoin library","type":"extras"},{"doc":"entropy = Btc.Util.strong_rand() {:ok, {priv_key, address}} = Btc.Address.generate(:p2pkh, :mainnet, entropy) true = Btc.Address.verify?(:p2pkh, :mainnet, address){:ok, {priv_key, address}} = Btc.Address.generate(:p2sh, :mainnet) true = Btc.Address.verify?(:p2sh, :mainnet, address){:ok, {priv_key, address}} = Btc.Address.generate(:p2wpkh, :testnet) true = Btc.Address.verify?(:p2wpkh, :testnet, address)","ref":"readme.html#usage","title":"Basic bitcoin library - Usage","type":"extras"},{"doc":"Prefixhttps://en.bitcoin.it/wiki/List_of_address_prefixes","ref":"readme.html#reference","title":"Basic bitcoin library - Reference","type":"extras"},{"doc":"https://bitcoin.stackexchange.com/questions/93966/getting-public-key-from-any-raw-transaction-what-to-take-care-ofhttps://bitcoin.stackexchange.com/questions/64733/what-is-p2pk-p2pkh-p2sh-p2wpkh-eli5Addresshttps://en.bitcoin.it/wiki/Invoice_addressP2PKHhttps://en.bitcoinwiki.org/wiki/Pay-to-Pubkey_HashP2SHhttps://en.bitcoin.it/wiki/Pay_to_script_hashhttps://en.bitcoin.it/wiki/BIP_0016","ref":"readme.html#overview","title":"Basic bitcoin library - Overview","type":"extras"},{"doc":"https://en.bitcoin.it/wiki/Script#Opcodes","ref":"readme.html#other","title":"Basic bitcoin library - Other","type":"extras"},{"doc":"","ref":"changelog.html","title":"CHANGELOG","type":"extras"}]